/************************************************************************
 *  File: nevispci_diag.c
 *
 *  Sample user-mode diagnostics application for accessing NEVISPCI
 *  devices using WinDriver's API.
 *  Code was generated by DriverWizard v11.00.
 *  Code was edited by jcrespo to remove unused functions which conflict with v12.60.
 *
 *  Jungo Confidential. Copyright (c) 2012 Jungo Ltd.  http://www.jungo.com
 *************************************************************************/
#ifndef LINUX
#define LINUX
#endif

#include <stdio.h>
#include "wdc_defs.h"
#include "wdc_lib.h"
#include "utils.h"
#include "status_strings.h"
#include "samples/shared/diag_lib.h"
#include "samples/shared/wdc_diag_lib.h"
#include "pci_regs.h"
#include "nevispci_lib.h"

/*************************************************************
 *  General definitions
 *************************************************************/
/* Error messages display */
#define NEVISPCI_ERR printf

/*************************************************************
 *  Global variables
 *************************************************************/
/* User's input command */
static CHAR gsInput[256];

/* --------------------------------------------------
 *    NEVISPCI configuration registers information
 *   -------------------------------------------------- */
/* Configuration registers information array */
const WDC_REG gNEVISPCI_CfgRegs[] =
{
    { WDC_AD_CFG_SPACE, PCI_VID, WDC_SIZE_16, WDC_READ_WRITE, "VID", "Vendor ID" },
    { WDC_AD_CFG_SPACE, PCI_DID, WDC_SIZE_16, WDC_READ_WRITE, "DID", "Device ID" },
    { WDC_AD_CFG_SPACE, PCI_CR, WDC_SIZE_16, WDC_READ_WRITE, "CMD", "Command" },
    { WDC_AD_CFG_SPACE, PCI_SR, WDC_SIZE_16, WDC_READ_WRITE, "STS", "Status" },
    { WDC_AD_CFG_SPACE, PCI_REV, WDC_SIZE_32, WDC_READ_WRITE, "RID_CLCD", "Revision ID & Class Code" },
    { WDC_AD_CFG_SPACE, PCI_CCSC, WDC_SIZE_8, WDC_READ_WRITE, "SCC", "Sub Class Code" },
    { WDC_AD_CFG_SPACE, PCI_CCBC, WDC_SIZE_8, WDC_READ_WRITE, "BCC", "Base Class Code" },
    { WDC_AD_CFG_SPACE, PCI_CLSR, WDC_SIZE_8, WDC_READ_WRITE, "CALN", "Cache Line Size" },
    { WDC_AD_CFG_SPACE, PCI_LTR, WDC_SIZE_8, WDC_READ_WRITE, "LAT", "Latency Timer" },
    { WDC_AD_CFG_SPACE, PCI_HDR, WDC_SIZE_8, WDC_READ_WRITE, "HDR", "Header Type" },
    { WDC_AD_CFG_SPACE, PCI_BISTR, WDC_SIZE_8, WDC_READ_WRITE, "BIST", "Built-in Self Test" },
    { WDC_AD_CFG_SPACE, PCI_BAR0, WDC_SIZE_32, WDC_READ_WRITE, "BADDR0", "Base Address 0" },
    { WDC_AD_CFG_SPACE, PCI_BAR1, WDC_SIZE_32, WDC_READ_WRITE, "BADDR1", "Base Address 1" },
    { WDC_AD_CFG_SPACE, PCI_BAR2, WDC_SIZE_32, WDC_READ_WRITE, "BADDR2", "Base Address 2" },
    { WDC_AD_CFG_SPACE, PCI_BAR3, WDC_SIZE_32, WDC_READ_WRITE, "BADDR3", "Base Address 3" },
    { WDC_AD_CFG_SPACE, PCI_BAR4, WDC_SIZE_32, WDC_READ_WRITE, "BADDR4", "Base Address 4" },
    { WDC_AD_CFG_SPACE, PCI_BAR5, WDC_SIZE_32, WDC_READ_WRITE, "BADDR5", "Base Address 5" },
    { WDC_AD_CFG_SPACE, PCI_CIS, WDC_SIZE_32, WDC_READ_WRITE, "CIS", "CardBus CIS Pointer" },
    { WDC_AD_CFG_SPACE, PCI_SVID, WDC_SIZE_16, WDC_READ_WRITE, "SVID", "Sub-system Vendor ID" },
    { WDC_AD_CFG_SPACE, PCI_SDID, WDC_SIZE_16, WDC_READ_WRITE, "SDID", "Sub-system Device ID" },
    { WDC_AD_CFG_SPACE, PCI_EROM, WDC_SIZE_32, WDC_READ_WRITE, "EROM", "Expansion ROM Base Address" },
    { WDC_AD_CFG_SPACE, PCI_CAP, WDC_SIZE_8, WDC_READ_WRITE, "NEW_CAP", "New Capabilities Pointer" },
    { WDC_AD_CFG_SPACE, PCI_ILR, WDC_SIZE_32, WDC_READ_WRITE, "INTLN", "Interrupt Line" },
    { WDC_AD_CFG_SPACE, PCI_IPR, WDC_SIZE_32, WDC_READ_WRITE, "INTPIN", "Interrupt Pin" },
    { WDC_AD_CFG_SPACE, PCI_MGR, WDC_SIZE_32, WDC_READ_WRITE, "MINGNT", "Minimum Required Burst Period" },
    { WDC_AD_CFG_SPACE, PCI_MLR, WDC_SIZE_32, WDC_READ_WRITE, "MAXLAT", "Maximum Latency" },
};
#define NEVISPCI_CFG_REGS_NUM sizeof(gNEVISPCI_CfgRegs) / sizeof(WDC_REG)
/* TODO: For read-only or write-only registers, change the direction field of
 *         the relevant registers in gNEVISPCI_CfgRegs to WDC_READ or WDC_WRITE. */
/* NOTE: You can define additional configuration registers in gNEVISPCI_CfgRegs. */
const WDC_REG *gpNEVISPCI_CfgRegs = gNEVISPCI_CfgRegs;

/* -----------------------------------------------
 *    NEVISPCI run-time registers information
 *   ----------------------------------------------- */
/* Run-time registers information array */
/* const WDC_REG gNEVISPCI_Regs[]; */
const WDC_REG *gpNEVISPCI_Regs = NULL;
/* TODO: You can remove the comment from the gNEVISPCI_Regs array declaration and
 *         fill the array with run-time registers information for your device,
 *         in which case be sure to set gpNEVISPCI_Regs to point to gNEVISPCI_Regs. */
#define NEVISPCI_REGS_NUM 0

/*************************************************************
 *  Static functions prototypes
 *************************************************************/

/* -----------------------------------------------
 *    Device find, open and close
 *   ----------------------------------------------- */
static WDC_DEVICE_HANDLE DeviceFindAndOpen(DWORD dwVendorId, DWORD dwDeviceId, DWORD dwBus);
static BOOL DeviceFind(DWORD dwVendorId, DWORD dwDeviceId, DWORD dwBus, WD_PCI_SLOT *pSlot);
static WDC_DEVICE_HANDLE DeviceOpen(const WD_PCI_SLOT *pSlot);
static void DeviceClose(WDC_DEVICE_HANDLE hDev);

/*************************************************************
 *  Functions implementation
 *************************************************************/

/* -----------------------------------------------
 *    Device find, open and close
 *   ----------------------------------------------- */
/* Find and open a NEVISPCI device */
static WDC_DEVICE_HANDLE DeviceFindAndOpen(DWORD dwVendorId, DWORD dwDeviceId, DWORD dwBus)
{
    WD_PCI_SLOT slot;

    if(!DeviceFind(dwVendorId, dwDeviceId, dwBus, &slot))
    {
        return NULL;
    }

    return DeviceOpen(&slot);
}

/* Find a NEVISPCI device */
static BOOL DeviceFind(DWORD dwVendorId, DWORD dwDeviceId, DWORD dwBus, WD_PCI_SLOT *pSlot)
{
    DWORD dwStatus;
    DWORD i, dwNumDevices;
    WDC_PCI_SCAN_RESULT scanResult;

    if(dwVendorId == 0)
    {
        if(DIAG_INPUT_SUCCESS != DIAG_InputDWORD((PVOID) &dwVendorId,
                "Enter vendor ID", TRUE, 0, 0))
        {
            return FALSE;
        }

        if(DIAG_INPUT_SUCCESS != DIAG_InputDWORD((PVOID) &dwDeviceId,
                "Enter device ID", TRUE, 0, 0))
        {
            return FALSE;
        }
    }

    BZERO(scanResult);

    dwStatus = WDC_PciScanDevices(dwVendorId, dwDeviceId, &scanResult);

    if(WD_STATUS_SUCCESS != dwStatus)
    {
        NEVISPCI_ERR("DeviceFind: Failed scanning the PCI bus.\n"
                      "Error: 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
        return FALSE;
    }

    dwNumDevices = scanResult.dwNumDevices;

    if(!dwNumDevices)
    {
        NEVISPCI_ERR("No matching device was found for search criteria "
                      "(Vendor ID 0x%lX, Device ID 0x%lX)\n",
                      dwVendorId, dwDeviceId);

        return FALSE;
    }


    for(i = 0; i < dwNumDevices; i++)
    {
        if(scanResult.deviceSlot[i].dwBus == dwBus)
        {
            *pSlot = scanResult.deviceSlot[i];
            
            return TRUE;
        }
    }

    printf("\n");

    printf("Found %ld matching device%s [ Vendor ID 0x%lX%s, Device ID 0x%lX%s ]:\n",
           dwNumDevices, dwNumDevices > 1 ? "s" : "",
           dwVendorId, dwVendorId ? "" : " (ALL)",
           dwDeviceId, dwDeviceId ? "" : " (ALL)");

    for(i = 0; i < dwNumDevices; i++)
    {
        printf("\n");
        printf("%2ld. Vendor ID: 0x%lX, Device ID: 0x%lX\n",
               i + 1,
               scanResult.deviceId[i].dwVendorId,
               scanResult.deviceId[i].dwDeviceId);

        WDC_DIAG_PciDeviceInfoPrint(&scanResult.deviceSlot[i], FALSE);
    }

    printf("\n");

    if(dwNumDevices > 1)
    {
        sprintf(gsInput, "Select a device (1 - %ld): ", dwNumDevices);
        i = 0;

        if(DIAG_INPUT_SUCCESS != DIAG_InputDWORD((PVOID) &i,
                gsInput, FALSE, 1, dwNumDevices))
        {
            return FALSE;
        }
    }

    *pSlot = scanResult.deviceSlot[i - 1];

    return TRUE;
}

/* Open a handle to a NEVISPCI device */
static WDC_DEVICE_HANDLE DeviceOpen(const WD_PCI_SLOT *pSlot)
{
    WDC_DEVICE_HANDLE hDev;
    DWORD dwStatus;
    WD_PCI_CARD_INFO deviceInfo;

    /* Retrieve the device's resources information */
    BZERO(deviceInfo);
    deviceInfo.pciSlot = *pSlot;
    dwStatus = WDC_PciGetDeviceInfo(&deviceInfo);

    if(WD_STATUS_SUCCESS != dwStatus)
    {
        NEVISPCI_ERR("DeviceOpen: Failed retrieving the device's resources information.\n"
                      "Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
        return NULL;
    }

    /* NOTE: You can modify the device's resources information here, if
     *       necessary (mainly the deviceInfo.Card.Items array or the items number -
     *       deviceInfo.Card.dwItems) in order to register only some of the resources
     *       or register only a portion of a specific address space, for example. */

    /* Open a handle to the device */
    hDev = NEVISPCI_DeviceOpen(&deviceInfo);

    if(!hDev)
    {
        NEVISPCI_ERR("DeviceOpen: Failed opening a handle to the device: %s",
                      NEVISPCI_GetLastErr());
        return NULL;
    }

    return hDev;
}

/* Close handle to a NEVISPCI device */
static void DeviceClose(WDC_DEVICE_HANDLE hDev)
{
    if(!hDev)
    {
        return;
    }

    if(!NEVISPCI_DeviceClose(hDev))
    {
        NEVISPCI_ERR("DeviceClose: Failed closing NEVISPCI device: %s",
                      NEVISPCI_GetLastErr());
    }
}

extern "C" {
    /*************************************************************
     *  Static functions prototypes
     *************************************************************/

    /* -----------------------------------------------
     *    Device find, open and close
     *   ----------------------------------------------- */
    WDC_DEVICE_HANDLE deviceFindAndOpen(DWORD dwVendorId, DWORD dwDeviceId, DWORD dwBus)
    {
        return DeviceFindAndOpen(dwVendorId, dwDeviceId, dwBus);
    }

    BOOL deviceFind(DWORD dwVendorId, DWORD dwDeviceId, DWORD dwBus, WD_PCI_SLOT *pSlot)
    {
        return DeviceFind(dwVendorId, dwDeviceId, dwBus, pSlot);
    }

    WDC_DEVICE_HANDLE deviceOpen(const WD_PCI_SLOT *pSlot)
    {
        return DeviceOpen(pSlot);
    }

    void deviceClose(WDC_DEVICE_HANDLE hDev)
    {
        return DeviceClose(hDev);
    }
}

